"use strict";exports.id=723,exports.ids=[723,144],exports.modules={4144:(e,t,r)=>{r.r(t),r.d(t,{createOrReadKeyless:()=>N,removeKeyless:()=>T,safeParseClerkFile:()=>E});var n=r(3704),o=r(4750),s=r(7745);r(6461);var l=r(3973),u=r(5723);async function c(){var e,t,r,n,o,s;let u=await (0,l.headers)();return{nodeVersion:process.version,nextVersion:function(){var e;try{return null!=(e=process.title)?e:"unknown-process-title"}catch{return}}(),npmConfigUserAgent:process.env.npm_config_user_agent,userAgent:null!=(e=u.get("User-Agent"))?e:"unknown user-agent",port:process.env.PORT,host:null!=(t=u.get("host"))?t:"unknown host",xPort:null!=(r=u.get("x-forwarded-port"))?r:"unknown x-forwarded-port",xHost:null!=(n=u.get("x-forwarded-host"))?n:"unknown x-forwarded-host",xProtocol:null!=(o=u.get("x-forwarded-proto"))?o:"unknown x-forwarded-proto",xClerkAuthStatus:null!=(s=u.get("x-clerk-auth-status"))?s:"unknown x-clerk-auth-status",isCI:function(){let e=new Set(["","false","0","no"]);return i.some(t=>{let r=process.env[t];if(void 0===r)return!1;let n=r.trim().toLowerCase();return!e.has(n)})}()}}let i=["CI","CONTINUOUS_INTEGRATION","BUILD_NUMBER","BUILD_ID","BUILDKITE","CIRCLECI","GITHUB_ACTIONS","GITLAB_CI","JENKINS_URL","TRAVIS","APPVEYOR","WERCKER","DRONE","CODESHIP","SEMAPHORE","SHIPPABLE","TEAMCITY_VERSION","BAMBOO_BUILDKEY","GO_PIPELINE_NAME","TF_BUILD","SYSTEM_TEAMFOUNDATIONCOLLECTIONURI","BITBUCKET_BUILD_NUMBER","HEROKU_TEST_RUN_ID","VERCEL","NETLIFY"];async function a(e){let t=new Headers;return e.nodeVersion&&t.set("Clerk-Node-Version",e.nodeVersion),e.nextVersion&&t.set("Clerk-Next-Version",e.nextVersion),e.npmConfigUserAgent&&t.set("Clerk-NPM-Config-User-Agent",e.npmConfigUserAgent),e.userAgent&&t.set("Clerk-Client-User-Agent",e.userAgent),e.port&&t.set("Clerk-Node-Port",e.port),e.host&&t.set("Clerk-Client-Host",e.host),e.xPort&&t.set("Clerk-X-Port",e.xPort),e.xHost&&t.set("Clerk-X-Host",e.xHost),e.xProtocol&&t.set("Clerk-X-Protocol",e.xProtocol),e.xClerkAuthStatus&&t.set("Clerk-Auth-Status",e.xClerkAuthStatus),e.isCI&&t.set("Clerk-Is-CI","true"),t}(0,u.h)([c,a]),(0,s.j)("4cc9d19e0d5856e7c15252f4c96ba5449841282b",c),(0,s.j)("598c1ab8d49c74911fc30790db2136bb324b19eb",a);let d=".clerk",f="clerk.lock",C=(...e)=>{let t=(0,o.t$)(),r=(0,o.t0)();return t.join(r(),d,...e)},I=".tmp",g=()=>C(I,"keyless.json"),h=()=>C(I,"README.md"),k=!1;function E(){let{readFileSync:e}=(0,o.ur)();try{let t;let r=g();try{t=e(r,{encoding:"utf-8"})||"{}"}catch{t="{}"}return JSON.parse(t)}catch{return}}let p=()=>{let{writeFileSync:e}=(0,o.ur)();k=!0,e(f,"This file can be deleted. Please delete this file and refresh your application",{encoding:"utf8",mode:"0777",flag:"w"})},A=()=>{let{rmSync:e}=(0,o.ur)();try{e(f,{force:!0,recursive:!0})}catch{}k=!1},x=()=>{let{existsSync:e}=(0,o.ur)();return k||e(f)};async function N(){let{writeFileSync:e,mkdirSync:t}=(0,o.ur)();if(x())return null;p();let r=g(),s=h();t(C(I),{recursive:!0}),function(){let{existsSync:e,writeFileSync:t,readFileSync:r,appendFileSync:n}=(0,o.ur)(),s=(0,o.t$)(),l=(0,o.t0)(),u=s.join(l(),".gitignore");e(u)||t(u,""),r(u,"utf-8").includes(d+"/")||n(u,`
# clerk configuration (can include secrets)
/${d}/
`)}();let l=E();if((null==l?void 0:l.publishableKey)&&(null==l?void 0:l.secretKey))return A(),l;let u=(0,n.f)({}),i=await c().then(a).catch(()=>new Headers),f=await u.__experimental_accountlessApplications.createAccountlessApplication({requestHeaders:i}).catch(()=>null);return f&&(e(r,JSON.stringify(f),{encoding:"utf8",mode:"0777",flag:"w"}),e(s,`
## DO NOT COMMIT
This directory is auto-generated from \`@clerk/nextjs\` because you are running in Keyless mode. Avoid committing the \`.clerk/\` directory as it includes the secret key of the unclaimed instance.
  `,{encoding:"utf8",mode:"0777",flag:"w"})),A(),f}function T(){let{rmSync:e}=(0,o.ur)();if(!x()){p();try{e(C(),{force:!0,recursive:!0})}catch{}A()}}}};